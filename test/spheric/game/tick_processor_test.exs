defmodule Spheric.Game.TickProcessorTest do
  use ExUnit.Case, async: false

  alias Spheric.Game.{Behaviors, TickProcessor, WorldStore}

  # Use a face with resource tiles for miner tests
  # Face 0 tiles are generated by WorldGen, so we manually set resource tiles
  @miner_key {15, 1, 1}
  @conveyor1_key {15, 1, 2}
  @conveyor2_key {15, 1, 3}
  @smelter_key {15, 1, 4}

  setup do
    # Ensure clean building state
    cleanup_keys = [@miner_key, @conveyor1_key, @conveyor2_key, @smelter_key]
    Enum.each(cleanup_keys, &WorldStore.remove_building/1)

    # Use grassland (neutral in all shift phases) so ShiftCycle doesn't affect rates
    WorldStore.put_tile(@miner_key, %{terrain: :grassland, resource: {:iron, 100}})

    on_exit(fn ->
      Enum.each(cleanup_keys, &WorldStore.remove_building/1)
      WorldStore.put_tile(@miner_key, %{terrain: :grassland, resource: {:iron, 100}})
    end)

    :ok
  end

  describe "process_tick/1 with no buildings" do
    test "returns empty items_by_face" do
      {tick, items_by_face, _submissions, _completed, _drone_completions} = TickProcessor.process_tick(1)
      assert tick == 1
      # May have items from existing buildings in other tests, but no buildings we placed
      assert is_map(items_by_face)
    end
  end

  describe "miner extraction" do
    test "miner produces ore after enough ticks" do
      # Place a miner on a resource tile
      WorldStore.put_building(@miner_key, %{
        type: :miner,
        orientation: 0,
        state: %{output_buffer: nil, progress: 0, rate: 5}
      })

      # Tick 5 times
      for i <- 1..5 do
        TickProcessor.process_tick(i)
      end

      building = WorldStore.get_building(@miner_key)
      assert building.state.output_buffer == :iron_ore
    end

    test "miner stalls with full output buffer and no downstream" do
      WorldStore.put_building(@miner_key, %{
        type: :miner,
        orientation: 0,
        state: %{output_buffer: :iron_ore, progress: 0, rate: 5}
      })

      TickProcessor.process_tick(1)

      building = WorldStore.get_building(@miner_key)
      # Output buffer still full (no downstream to accept)
      assert building.state.output_buffer == :iron_ore
    end
  end

  describe "conveyor movement" do
    test "item moves from miner to adjacent conveyor" do
      # Miner at {15,1,1} orientation 0 (col+1) -> pushes to {15,1,2}
      WorldStore.put_building(@miner_key, %{
        type: :miner,
        orientation: 0,
        state: %{output_buffer: :iron_ore, progress: 0, rate: 5}
      })

      WorldStore.put_building(@conveyor1_key, %{
        type: :conveyor,
        orientation: 0,
        state: %{item: nil}
      })

      TickProcessor.process_tick(1)

      miner = WorldStore.get_building(@miner_key)
      conveyor = WorldStore.get_building(@conveyor1_key)

      assert miner.state.output_buffer == nil
      assert conveyor.state.item == :iron_ore
    end

    test "item moves along conveyor chain" do
      # Conveyor 1 at {15,1,2} has item, orientation 0 -> pushes to {15,1,3}
      WorldStore.put_building(@conveyor1_key, %{
        type: :conveyor,
        orientation: 0,
        state: %{item: :iron_ore}
      })

      WorldStore.put_building(@conveyor2_key, %{
        type: :conveyor,
        orientation: 0,
        state: %{item: nil}
      })

      TickProcessor.process_tick(1)

      c1 = WorldStore.get_building(@conveyor1_key)
      c2 = WorldStore.get_building(@conveyor2_key)

      assert c1.state.item == nil
      assert c2.state.item == :iron_ore
    end

    test "conveyor does not push to occupied conveyor" do
      WorldStore.put_building(@conveyor1_key, %{
        type: :conveyor,
        orientation: 0,
        state: %{item: :iron_ore}
      })

      WorldStore.put_building(@conveyor2_key, %{
        type: :conveyor,
        orientation: 0,
        state: %{item: :copper_ore}
      })

      TickProcessor.process_tick(1)

      c1 = WorldStore.get_building(@conveyor1_key)
      c2 = WorldStore.get_building(@conveyor2_key)

      # Neither should change â€” c2 is full
      assert c1.state.item == :iron_ore
      assert c2.state.item == :copper_ore
    end

    test "conveyor does not push to empty tile (no building)" do
      WorldStore.put_building(@conveyor1_key, %{
        type: :conveyor,
        orientation: 0,
        state: %{item: :iron_ore}
      })

      # No building at conveyor2_key
      TickProcessor.process_tick(1)

      c1 = WorldStore.get_building(@conveyor1_key)
      assert c1.state.item == :iron_ore
    end
  end

  describe "smelter processing" do
    test "smelter processes ore over multiple ticks" do
      smelter_state = Map.merge(Behaviors.Smelter.initial_state(), %{input_buffer: :iron_ore, input_count: 1})

      WorldStore.put_building(@smelter_key, %{
        type: :smelter,
        orientation: 0,
        state: smelter_state
      })

      # Tick 10 times
      for i <- 1..10 do
        TickProcessor.process_tick(i)
      end

      smelter = WorldStore.get_building(@smelter_key)
      assert smelter.state.input_buffer == nil
      assert smelter.state.output_buffer == :iron_ingot
    end

    test "conveyor feeds item into smelter input" do
      WorldStore.put_building(@conveyor2_key, %{
        type: :conveyor,
        orientation: 0,
        state: %{item: :iron_ore}
      })

      WorldStore.put_building(@smelter_key, %{
        type: :smelter,
        orientation: 0,
        state: Behaviors.Smelter.initial_state()
      })

      TickProcessor.process_tick(1)

      conveyor = WorldStore.get_building(@conveyor2_key)
      smelter = WorldStore.get_building(@smelter_key)

      assert conveyor.state.item == nil
      assert smelter.state.input_buffer == :iron_ore
    end
  end

  describe "full production chain" do
    test "miner -> conveyor -> conveyor -> smelter end-to-end" do
      WorldStore.put_building(@miner_key, %{
        type: :miner,
        orientation: 0,
        state: %{output_buffer: nil, progress: 0, rate: 5}
      })

      WorldStore.put_building(@conveyor1_key, %{
        type: :conveyor,
        orientation: 0,
        state: %{item: nil}
      })

      WorldStore.put_building(@conveyor2_key, %{
        type: :conveyor,
        orientation: 0,
        state: %{item: nil}
      })

      WorldStore.put_building(@smelter_key, %{
        type: :smelter,
        orientation: 0,
        state: Behaviors.Smelter.initial_state()
      })

      # Tick enough times for full chain:
      # 5 ticks: miner extracts ore
      # 1 tick: ore pushed to conveyor1
      # 1 tick: ore moves to conveyor2
      # 1 tick: ore enters smelter
      # 10 ticks: smelter processes
      # Total: ~18 ticks to see ingot in smelter output
      for i <- 1..20 do
        TickProcessor.process_tick(i)
      end

      smelter = WorldStore.get_building(@smelter_key)
      assert smelter.state.output_buffer == :iron_ingot
    end
  end

  describe "item snapshot broadcasting" do
    test "process_tick returns item positions in items_by_face" do
      WorldStore.put_building(@conveyor1_key, %{
        type: :conveyor,
        orientation: 0,
        state: %{item: :iron_ore}
      })

      WorldStore.put_building(@conveyor2_key, %{
        type: :conveyor,
        orientation: 0,
        state: %{item: nil}
      })

      {_tick, items_by_face, _submissions, _completed, _drone_completions} = TickProcessor.process_tick(1)

      # After the push, the item should be on conveyor2 (face 15)
      face_items = Map.get(items_by_face, 15, [])
      item = Enum.find(face_items, fn i -> i.row == 1 and i.col == 3 end)

      assert item != nil
      assert item.item == :iron_ore
      assert item.from_face == 15
      assert item.from_row == 1
      assert item.from_col == 2
    end

    test "stationary items have nil from fields" do
      WorldStore.put_building(@miner_key, %{
        type: :miner,
        orientation: 0,
        state: %{output_buffer: :iron_ore, progress: 0, rate: 5}
      })

      # No downstream building, so item stays in miner buffer
      {_tick, items_by_face, _submissions, _completed, _drone_completions} = TickProcessor.process_tick(1)

      face_items = Map.get(items_by_face, 15, [])
      item = Enum.find(face_items, fn i -> i.row == 1 and i.col == 1 end)

      assert item != nil
      assert item.item == :iron_ore
      assert item.from_face == nil
    end
  end
end
